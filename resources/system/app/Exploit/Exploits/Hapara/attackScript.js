(function() {
  'use strict';
  chrome.notifications.create('STARTUP_TEST', {
    type: 'basic',
    iconUrl: 'icons/icon128.png',
    title: 'Hapara Hijacked',
    message: 'Your Current Windows Are Hidden and Immune. Make sure to leave at least one non-hidden window open, or else unpredictable bugs may occur. We are currently working on Focused Browsing and Storage interception.',
    priority: 2,
    requireInteraction: true
  });
  /*Store Window Objects Here*/
  var hidden = [];
  var unprotected = [];
  var queue = {
    /*Only used for event listeners*/
    windows: {
      focusChanged: [],
      created: []
    },
    tabs: {
      onCreated: [],
      onUpdated: [],
      onActivated: [],
      onAttached: [],
      onReplaced: []
    },
    webRequest: {
      onBeforeRedirect: [],
      onBeforeRequest: [],
      onCompleted: [],
      onSendHeaders: [],
      onAuthRequired: [],
      onResponseStarted: []
    }
  };
  var _api = {
    windows: {
      onCreated: chrome.windows.onCreated.addListener,
      onFocusChanged: chrome.windows.onFocusChanged.addListener,
      getCurrent: chrome.windows.getCurrent,
      getLastFocused: chrome.windows.getLastFocused,
      getAll: chrome.windows.getAll
    },
    tabs: {
      onCreated: chrome.tabs.onCreated.addListener,
      onUpdated: chrome.tabs.onUpdated.addListener,
      onActivated: chrome.tabs.onActivated.addListener,
      onAttached: chrome.tabs.onAttached.addListener,
      onReplaced: chrome.tabs.onReplaced.addListener,
      query: chrome.tabs.query,
      getCurrent: chrome.tabs.getCurrent
    },
    webRequest: {
      onBeforeRedirect: {
        addListener: chrome.webRequest.onBeforeRedirect.addListener,
        removeListener: chrome.webRequest.onBeforeRedirect.removeListener
      }, onBeforeRequest: {
        addListener: chrome.webRequest.onBeforeRequest.addListener,
        removeListener: chrome.webRequest.onBeforeRequest.removeListener
      }, onCompleted: {
        addListener: chrome.webRequest.onCompleted.addListener,
        removeListener: chrome.webRequest.onCompleted.removeListener
      }, onSendHeaders: {
        addListener: chrome.webRequest.onSendHeaders.addListener,
        removeListener: chrome.webRequest.onSendHeaders.removeListener
      }, onAuthRequired: {
        addListener: chrome.webRequest.onAuthRequired.addListener,
        removeListener: chrome.webRequest.onAuthRequired.removeListener
      }, onResponseStarted: {
        addListener: chrome.webRequest.onResponseStarted.addListener,
        removeListener: chrome.webRequest.onResponseStarted.removeListener
      }
    }
  };
  /*Intercept All Network Traffic*/
  var init = false;
  var xhrController = {
    sendMessage: function() {
      xhrController.queue.push(arguments);
    },
    queue: []
  };
  var url = URL.createObjectURL(new Blob([`
    <html>
      <head>
        <title>
          Hapara Traffic Intercepter
        </title>
      </head>
      <body>
        <script>
          chrome.runtime.onMessage.addListener(
            function(request, sender, sendResponse) {
              console.log(arguments);
              log(sendResponse);
            });
          var log = function(msg) {
            if (typeof msg == 'object') {
              msg = JSON.stringify(msg);
            }
            msgContainer = document.createElement('div');
            msgContainer.innerText = msg;
            msgContainer.style.width = '100%';
            document.body.appendChild(msgContainer);
          };
        </script>
      </body>
    </html>
  `], {type: 'text/html'}));
  chrome.windows.create({
    focused: false,
    left: 0,
    top: 0,
    width: 350,
    height: 750,
    type: 'popup',
    url: [url]},
    function(win) {
      init = true;
      hidden.push(win);
      xhrController.id = win.tabs[0].id;
      xhrController.sendMessage = function(msg, callback) {
        console.log(msg);
        console.log(xhrController);
        chrome.tabs.sendMessage(xhrController.id, msg, function(response) {
          if (callback) {
            callback(response);
          }
        }.bind(this));
      }.bind(this);
      for (let i = 0, ii = xhrController.queue.length; i != ii; i++) {
        xhrController.sendMessage.apply(this, xhrController.queue[i]);
      }
    }.bind(this)
  );
  xhrController.sendMessage({
    type: 'info',
    data: 'This is just an interface for you to monitor all network traffic.'
  });
  xhrController.sendMessage({
    type: 'info',
    data: 'You can close this window if you want.'
  });
  /*Hijack window event calls*/
  chrome.windows.onCreated.addListener(function(windowObj) {
    /*Fired When A new window is created and asynchronously prompts user for confirmation*/
    if (!init) {
      return;
    }
    hidden.push(windowObj);
    chrome.notifications.create('WINDOW_SETUP|' + windowObj.id, {
      type: 'basic',
      iconUrl: 'icons/icon128.png',
      title: 'Protect This Window?',
      message: 'Tabs in this window will be invisible.',
      buttons: [{
        title: 'Yes'
      }, {
        title: 'No'
      }],
      priority: 1,
      requireInteraction: true
    });
  }.bind(this));
  chrome.notifications.onButtonClicked.addListener(function(id, btnIndex) {
    /*Listens for the asynchronous user response to the dialogue generated above. Until the user confirms or denys, the window is hidden*/
    id = id.split('|');
    if (id.length == 2) {
      if (id[0] == 'WINDOW_SETUP') {
        chrome.windows.get(parseInt(id[1]), null, function(windowObj) {
          if (btnIndex === 1) {
            for (let i = hidden.length - 1; i >= 0; i--) {
              if (hidden[i].id == windowObj.id) {
                hidden.splice(i, 1);
                break;
              }
            }
            unprotected.push(windowObj);
            for (let i = unprotected.length - 1; i >= 0; i--) {
              if (unprotected[i].id == windowObj.id) {
                for (let i = 0, ii = queue.windows.created; i != ii; i++) {
                  queue.windows.created[i](windowObj);
                }
                break;
              }
            }
          }
        }.bind(this));
      }
      chrome.notifications.clear(id.join('|'));
    }
  }.bind(this));
  chrome.windows.onFocusChanged.addListener(function(winId) {
    for (let i = unprotected.length - 1; i >= 0; i--) {
      if (unprotected[i] == winId) {
        for (let i = queue.windows.focusChanged.length - 1; i >= 0; i++) {
          queue.windows.focusChanged[i](winId);
        }
        break;
      }
    }
  }.bind(this));
  chrome.windows.onFocusChanged.addListener = function(callback) {
    queue.windows.focusChanged.push(callback);
  }.bind(this);
  chrome.windows.onFocusChanged.removeListener = function(callback) {
    for (let i = queue.windows.onFocusChanged.length - 1; i >= 0; i--) {
      if (queue.windows.onFocusChanged[i] == callback) {
        queue.windows.onFocusChanged.splice(i, 1);
      }
    }
  }.bind(this);
  chrome.windows.onCreated.addListener = function(callback) {
    queue.windows.onCreated.push(callback);
  }.bind(this);
  chrome.windows.onCreated.removeListener = function(callback) {
    for (let i = queue.windows.onCreated.length - 1; i >= 0; i--) {
      if (queue.windows.onCreated[i] == callback) {
        queue.windows.onCreated.splice(i, 1);
      }
    }
  }.bind(this);
  /*Hijack Functions (active) window scans*/
  chrome.windows.getCurrent = function(info, callback) {
    _api.windows.getCurrent(info, function(windows) {
      var currWindow = null;
      for (let i = unprotected.length - 1; i >= 0; i--) {
        if (unprotected[i].id == windows.id) {
          currWindow = unprotected[i];
          break;
        }
      }
      if (!currWindow && unprotected.length > 0) {
        currWindow = unprotected[0];
      }
      callback(windows);
    }.bind(this));
  }.bind(this);
  chrome.windows.getLastFocused = function(info, callback) {
    if (arguments.length == 1) {
      callback = info;
      info = null;
    }
    _api.windows.getLastFocused(info, function(windows) {
      var currWindow = null;
      for (let i = unprotected.length - 1; i >= 0; i--) {
        if (unprotected[i].id == windows.id) {
          currWindow = unprotected[i];
          break;
        }
      }
      if (!currWindow && unprotected.length > 0) {
        currWindow = unprotected[0];
      }
      callback(windows);
    }.bind(this));
  }.bind(this);
  chrome.windows.getAll = function(args, callback) {
    if (arguments.length == 1) {
      callback = args;
      args = null;
    }
    _api.windows.getAll(args, function(allWindows) {
      var result = [];
      for (let i = allWindows.length - 1; i >= 0; i--) {
        for (let ii = unprotected.length - 1; ii >= 0; ii--) {
          if (allWindows[i] && allWindows[i].id == unprotected[ii].id) {
            result.push(allWindows[i]);
          }
        }
      }
      callback(result);
    }.bind(this));
  }.bind(this);
  /*Hijack tabs event calls*/
  chrome.tabs.onCreated.addListener(function(tab) {
    for (let i = unprotected.length - 1; i >= 0; i++) {
      if (tab.windowId == unprotected[i].id) {
        for (let i = 0, ii = queue.onCreated.length; i != ii; i++) {
          queue.tabs.onCreated[i](tab);
        }
        break;
      }
    }
  }.bind(this));
  chrome.tabs.onCreated.addListener = function(callback) {
    queue.tabs.onCreated.push(callback);
  }.bind(this);
  chrome.tabs.onCreated.removeListener = function(callback) {
    for (let i = queue.tabs.onCreated.length - 1; i >= 0; i--) {
      if (queue.tabs.onCreated[i] == callback) {
        queue.tabs.onCreated.splice(i, 1);
      }
    }
  }.bind(this);

  chrome.tabs.onUpdated.addListener(function(tabId, changeInfo, tab) {
    for (let i = unprotected.length - 1; i >= 0; i++) {
      if (tab.windowId == unprotected[i].id) {
        for (let i = 0, ii = queue.onUpdated.length; i != ii; i++) {
          queue.tabs.onUpdated[i](tabId, changeInfo, tab);
        }
        break;
      }
    }
  }.bind(this));
  chrome.tabs.onUpdated.addListener = function(callback) {
    queue.tabs.onUpdated.push(callback);
  }.bind(this);
  chrome.tabs.onUpdated.removeListener = function(callback) {
    for (let i = queue.tabs.onUpdated.length - 1; i >= 0; i--) {
      if (queue.tabs.onUpdated[i] == callback) {
        queue.tabs.onUpdated.splice(i, 1);
      }
    }
  }.bind(this);

  chrome.tabs.onActivated.addListener(function(activeInfo) {
    for (let i = unprotected.length - 1; i >= 0; i++) {
      if (activeInfo.windowId == unprotected[i].id) {
        for (let i = 0, ii = queue.onActivated.length; i != ii; i++) {
          queue.tabs.onActivated[i](activeInfo);
        }
        break;
      }
    }
  }.bind(this));
  chrome.tabs.onActivated.addListener = function(callback) {
    queue.tabs.onActivated.push(callback);
  }.bind(this);
  chrome.tabs.onActivated.removeListener = function(callback) {
    for (let i = queue.tabs.onActivated.length - 1; i >= 0; i--) {
      if (queue.tabs.onActivated[i] == callback) {
        queue.tabs.onActivated.splice(i, 1);
      }
    }
  }.bind(this);

  chrome.tabs.onAttached.addListener(function(tabId, tab) {
    for (let i = unprotected.length - 1; i >= 0; i++) {
      if (tab.newWindowId == unprotected[i].id) {
        for (let i = 0, ii = queue.onAttached.length; i != ii; i++) {
          queue.tabs.onAttached[i](tabId, tab);
        }
        break;
      }
    }
  }.bind(this));
  chrome.tabs.onAttached.addListener = function(callback) {
    queue.tabs.onAttached.push(callback);
  }.bind(this);
  chrome.tabs.onAttached.removeListener = function(callback) {
    for (let i = queue.tabs.onAttached.length - 1; i >= 0; i--) {
      if (queue.tabs.onAttached[i] == callback) {
        queue.tabs.onAttached.splice(i, 1);
      }
    }
  }.bind(this);

  chrome.tabs.onReplaced.addListener(function(newTabId, oldTabId) {
    for (let index = unprotected.length - 1; index >= 0; index++) {
      _api.tabs.get(newTabId, function(tab) {
        if (tab.windowId == unprotected[index].id) {
          for (let i = 0, ii = queue.onReplaced.length; i != ii; i++) {
            queue.tabs.onReplaced[i](newTabId, oldTabId);
          }
        }
      }.bind(this));
    }
  }.bind(this));
  chrome.tabs.onReplaced.addListener = function(callback) {
    queue.tabs.onReplaced.push(callback);
  }.bind(this);
  chrome.tabs.onReplaced.removeListener = function(callback) {
    for (let i = queue.tabs.onReplaced.length - 1; i >= 0; i--) {
      if (queue.tabs.onReplaced[i] == callback) {
        queue.tabs.onReplaced.splice(i, 1);
      }
    }
  }.bind(this);
  /*Hijack Functions (active) tab scans*/
  /*These are the only ones they use, so...*/
  chrome.tabs.query = function(info, callback) {
    _api.tabs.query(info, function(tabs) {
      var output = [];
      for (let i = tabs.length - 1; i >= 0; i--) {
        for (let index = unprotected.length - 1; index >= 0; index--) {
          if (tabs[i].windowId == unprotected[index].id) {
            output.push(tabs);
          }
        }
      }
      callback(output);
    }.bind(this));
  }.bind(this);
  chrome.tabs.getCurrent = function(callback) {
    _api.tabs.getCurrent(function(tab) {
      for (let i = unprotected.length - 1; i >= 0; i--) {
        if (tab.windowId == unprotected[i]) {
          callback(tab);
          break;
        }
      }
    }.bind(this));
  }.bind(this);
  /*Hijack All WebRequest*/
  /*Let them directly interface with the real blocker function, but kick out the callback*/
  var webRequestHijack = function(args, target) {
    console.log('Hijacked added webRequest.' + target + ' Event Listener...');
    arguments[0] = function(callback, details) {
      var managed = false;
      for (let i = unprotected.length - 1; i >= 0 && !managed; i--) {
        for (let i = unprotected[i].tabs.length; i >= 0 && !managed; i--) {
          if (details.tabId == unprotected[i].tabs[i].id) {
            managed = true;
          }
        }
      }
      if (managed) {
        console.warn('Allowed Unprotected Tab traffic to be intercepted by Hapara');
        return callback(details);
      }
      console.log('Denied Protected Tab traffic from being intercepted by Hapara');
    }.bind(this, arguments[0]);
    queue.webRequest[target].push({prevFunc: arguments[0].toString()});
    _api.webRequest[target].addListener.apply(chrome.webRequest[target], args);
  }.bind(this);
  chrome.webRequest.onBeforeRedirect.addListener = function() {
    var target = 'onBeforeRedirect';
    webRequestHijack(arguments, target);
  }.bind(this);
  chrome.webRequest.onBeforeRedirect.removeListener = function(callback) {
    callback = callback.toString();
    for (let i = queue.webRequest.onBeforeRedirect.length - 1; i >= 0; i--) {
      if (queue.webRequest.onBeforeRedirect[i].callback) {
        queue.webRequest.onBeforeRedirect.splice(i, 1);
      }
    }
  }.bind(this);
  chrome.webRequest.onBeforeRequest.addListener = function() {
    var target = 'onBeforeRequest';
    webRequestHijack(arguments, target);
  }.bind(this);
  chrome.webRequest.onBeforeRequest.removeListener = function(callback) {
    callback = callback.toString();
    for (let i = queue.webRequest.onBeforeRequest.length - 1; i >= 0; i--) {
      if (queue.webRequest.onBeforeRequest[i].callback) {
        queue.webRequest.onBeforeRequest.splice(i, 1);
      }
    }
  }.bind(this);
  chrome.webRequest.onCompleted.addListener = function() {
    var target = 'onCompleted';
    webRequestHijack(arguments, target);
  }.bind(this);
  chrome.webRequest.onCompleted.removeListener = function(callback) {
    callback = callback.toString();
    for (let i = queue.webRequest.onCompleted.length - 1; i >= 0; i--) {
      if (queue.webRequest.onCompleted[i].callback) {
        queue.webRequest.onCompleted.splice(i, 1);
      }
    }
  }.bind(this);
  chrome.webRequest.onSendHeaders.addListener = function() {
    var target = 'onSendHeaders';
    webRequestHijack(arguments, target);
  }.bind(this);
  chrome.webRequest.onSendHeaders.removeListener = function(callback) {
    callback = callback.toString();
    for (let i = queue.webRequest.onSendHeaders.length - 1; i >= 0; i--) {
      if (queue.webRequest.onSendHeaders[i].callback) {
        queue.webRequest.onSendHeaders.splice(i, 1);
      }
    }
  }.bind(this);
  chrome.webRequest.onAuthRequired.addListener = function() {
    var target = 'onAuthRequired';
    webRequestHijack(arguments, target);
  }.bind(this);
  chrome.webRequest.onAuthRequired.removeListener = function(callback) {
    callback = callback.toString();
    for (let i = queue.webRequest.onAuthRequired.length - 1; i >= 0; i--) {
      if (queue.webRequest.onAuthRequired[i].callback) {
        queue.webRequest.onAuthRequired.splice(i, 1);
      }
    }
  }.bind(this);
  chrome.webRequest.onResponseStarted.addListener = function() {
    var target = 'onResponseStarted';
    webRequestHijack(arguments, target);
  }.bind(this);
  chrome.webRequest.onResponseStarted.removeListener = function(callback) {
    callback = callback.toString();
    for (let i = queue.webRequest.onResponseStarted.length - 1; i >= 0; i--) {
      if (queue.webRequest.onResponseStarted[i].callback) {
        queue.webRequest.onResponseStarted.splice(i, 1);
      }
    }
  }.bind(this);
  /*Filter XMLHttpRequest Calls*/
  (function(open, send) {
    var blackList = [
      'https://highlights-logging.teacherdashboard.com/log/javascript',
      'https://highlights-logging.teacherdashboard.com/log/bug-report'
    ];
    XMLHttpRequest.prototype.open = function(method, url, async, user, pass) {
      console.info(method, url, async);
      open.call(this, method, url, async, user, pass);
      this.allowedSend = true;
      if (blackList.includes(url)) {
        this.allowedSend = false;
      }
    };
    XMLHttpRequest.prototype.send = function(data) {
      if (this.allowedSend) {
        console.info.call(console, data);
        this.addEventListener('load', function() {
          console.info(this.responseText);
        }.bind(this));
        send.call(this, data);
      } else {
        console.error.call(console, data);
      }
    };
  })(XMLHttpRequest.prototype.open, XMLHttpRequest.prototype.send);
  _api.windows.getAll(null, function(windowArray) {
    hidden.concat(hidden, windowArray);
    /*Start Hapara*/
    console.log('All exploits are loaded, starting Hapara...');
    var loader = document.createElement('script');
    loader.src = chrome.runtime.getManifest().background.scripts[0];
    document.body.appendChild(loader);
    loader.addEventListener('load', function() {
      window.Raygun.detach();
      window.onerror = function() {
        console.error(arguments);
      };
    });
  }.bind(this));
})();
